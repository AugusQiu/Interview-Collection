# 基本概念
* 叶子节点:没有子节点的节点
* 兄弟节点:两个具有相同父节点的节点
* 子树:一个节点的子节点以及子节点的后代称为该节点的子树
* 树的深度(depth):从根节点开始（其深度为1）自顶向下逐层累加的
* 高度(height):  从根节点开始（其高度为0）自顶向下逐层累加的

二叉树:首先它是一种特殊的树，它是**每个节点最多有两个子树**的树    
**满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树**
## 二叉搜索树(二叉排序树，二叉查找树)
特点: **左小右大**
* 树中每个节点最多有两个子树，通常称为左子树和右子树
* 若它的左子树不空，则左子树上所有节点的值均小于它的根结点的值
* 若它的右子树不空，则右子树上所有节点的值均大于它的根结点的值
* 它的左右子树仍然是一棵二叉搜索树 (recursive)
## 平衡二叉树:
* 非叶子节点最多拥有两个子节点
* 子节点值，左小右大
* 树的左右两边的层数级不会大于1
* 没有值相等重复的节点  

优点:便于快速查找、查找的时间复杂度为O(logN)  
缺点:为了保证高度平衡，动态插入和删除的代价也随之增加  
https://www.jianshu.com/p/359e12ab8eef
### 红黑树是弱平衡二叉树
特点:
* 每个节点非红即黑
* 根节点是黑的
* 每个叶子节点都是黑的
* 如果一个节点是红的，那么它的两儿子都是黑的
红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树
## b树、b+树
https://blog.csdn.net/login_sonata/article/details/75268075  
b树(balance tree)和b+树应用在数据库索引  
为什么不用查找速度快、比较次数少的二叉树？  
要考虑磁盘IO的情况，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点），所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而**矮胖就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小**  
### 一个M阶的b树具有如下几个特征：
* 任意非叶子节点，最多只有M个儿子，且M>2
* 结点的儿子数为[2, M]
* 除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整
* 非叶子结点的关键字个数=儿子数-1
* 所有叶子结点位于同一层
* k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系  
### b+树
b+树，是b树的一种变体，查询性能更好，m阶的b+树的特征  
* 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）
* 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接  

b+树相比于b树的**查询优势**:  
* b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”
* b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）
* 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历
## 哈夫曼树、红黑树
https://blog.csdn.net/caoxuekun/article/details/77931281
## 堆
堆可以被看作近似完全二叉树的数组，大小堆，大堆：父结点的值都大于子结点
