https://juejin.im/entry/5acf784a5188255caf069a93#comment
## 判断文本是否为回文
````
//方法一
function isPalindrome1(val){
    if(typeof val !== 'string') val = val.toString();
    let newVal = val.split('').reverse().join(''); //split() 方法用于把一个字符串分割成字符串数组,才能再去调用reverse方法

    return val === newVal;
}

//方法二
function isPalindrome2(val){
    val = val +''; //非字符串转化为字符串

    // 这里为什么 i <= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！
    for(let i=0,j=val.length-1;i<j;i++,j--){
        if(val.charAt(i)!==val.charAt(j)){
            return false
        }
    }
    return true;
}
````
## 反转字符串
````
//方法一：借助反转字符串的方法
function reverseVal1(val){
    if(typeof val!=='string') return;
    return val.split('').reverse().join('');
}

//方法二(循环)
function reverseVal2(val){
    if(typeof val !== 'string') return;

    let str = '',len = val.length;
    for(let i=len-1;i>=0;i--){
        str += val.charAt(i)
    }
    return str;
}
````
## 阶乘
````
//方法一：递归
function factorialize1(n){
    if(typeof n !== 'number') throw new Error('参数必须为整')

    if(n === 1) return 1;
    return n * factorialize1(n-1);
}

//方法二，ES6尾调用优化
function factorialize2(n,total = 1){
    if(typeof n !== 'number' || typeof total !== 'number') throw new Error('参数必须为整')

    if(n === 1) return total;
    return factorialize2(n-1,n*total)
    
}

//方法三(循环)
function factorialize3(n){
    if(typeof n !== 'number') throw new Error('参数必须为整')
    if(n === 1) return 1;
    let total = 1;
    while(n>1){
        total = n*total;
        n--;
    }
    return total;
}
````
## 随机生成长度为n字符串
````
//方法一
function randomString1(n){
    let str = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let rem = '',
          i = 0;    
    while(i<n){
        tem += str.charAt(Math.floor(Math.random() * str.length))
		i++;
    }
    return tem;
}
````
## 数组去重
````
//方法一：ES6的Set数据结构
function unique1(arr){
    return [...new Set(arr)];
}

//方法二：对象的key唯一性
function unique2(arr){
    let obj = {},
        i   = 0,
        len = arr.length;
    
    while(i<len){
        if(!obj[arr[i]]){
            obj[arr[i]] = true;
        }
        i++;
    }
    return Object.keys(obj);
}

//该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串
会把数字1和字符串’1’，会被视为同一个值


//方法三：判断首次出现的位置
function unique3(arr){
    let tem = [arr[0]],
        len = arr.length;
    
    for(let i=1;i<len;i++){
        //核心，首次的索引出现是否为当前的索引
        if(arr.indexOf(arr[i]) === i) tem.push(arr[i]);
    }
    return tem;
}
````

