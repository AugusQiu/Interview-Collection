## fluteer和Dart
* Dart 单线程，可以在没有锁的情况下进行对象分配和垃圾回收。就像 JavaScript 一样，Dart 避免了抢占式调度和共享内存（因而也不需要锁）
## GrapthQL
graphQl能用于api查询，也能用于数据查询
* 按需请求资源
* 一个请求获取多个资源
* restful用不同的url来区分资源，GraphQL用类型区分资源
## 微前端
把前端应用拆分成更小、更易于管理的小应用
## Serverless(无服务)
是软件系统架构思想，用户无须关注服务器底层的计算资源，解耦应用和服务器资源
## 特点
* 按需加载：应用并非一直在线，只有请求发生时，云计算平台才会部署和加载；空闲久了，就会自动停止和卸载，因此应用不会持续占用计算资源
* 事件驱动：将不同事件来源（Event Source）的事件（Event）与特定的函数进行关联，实现对不同事件采取不同的反应动作
* 非会话保持：每次处理请求的应用实例可能是相同服务器上的应用实例，也可能是新生成的服务器上的应用实例，不能保证相同，无法做到传统意义上的会话保持（Sticky Session）。因此，Serverless架构更适合无状态的应用
* 自动弹性伸缩：Serverless 应用原生可以支持高可用，可以应对突发的高访问量。应用实例数量根据实际的访问量由云计算平台进行弹性的自动扩展或收缩，云计算平台动态地保证有足够的计算资源和足够数量的应用实例对请求进行处理
* 应用函数化：每一个调用完成一个业务动作，应用会被分解成多个细颗粒度的操作。由于状态无法本地持久化，这些细颗粒度的操作是无状态的，类似于传统编程里无状态的函数。Serverless 架构下的应用会被函数化，但不能说 Serverless 就是 Function as a Service（FaaS）。Serverless 涵盖了 FaaS 的一些特性，可以说 FaaS 是 Serverless 架构实现的一个重要手段
## 项目中遇到的问题
* 技术很新，整合起来，坑很多，查找资料，比对他人的业务代码，调研搭建基本的框架
* node12的net模块,连接ip地址和端口，socket打印本机的端口为undefined,后来手动指定设置本地端口
* 文本编码和buffer的转换，node：buffer模块，TextDecoder插件解决utf-8和gbk编码问题，ascii码转为对应字母:String.fromCharCode
## 项目工程化
* ui 组件化
* 程序代码 模块化
* git 分支 多人协作
* 接口规范
## 说说你对前端架构的认识，如何设计出一个架构方案
* 组件化
* 兼容性(不同浏览器)，两种兼容思路：渐进增强和优雅降级，css hack
###  适配移动端：  
* 单位英寸像素数（Pixel Per Inch，PPI）：现实世界的一英寸内像素数，决定了屏幕的显示质量  
* 设备像素比率（Device Pixel Ratio，DPR）：物理像素与逻辑像素（px）的对应关系 
* 分辨率（Resolution）：屏幕区域的宽高所占像素数
在当前环境下，分辨率适配可以使用 vw 单位解决，DPR 适配则需要用到 CSS 的 viewport 规则来控制缩放比例解决，而 PPI 主要影响的是文字，可以采用 media查询 规则来适配
### 单页应用
在一个“物理页面”内，通过架构设计来实现若干个“逻辑页面”。逻辑页面应该做到独立开发和独立发布，一种思路是，每个逻辑页面一个 JS，用一个 SPA 框架加载 JS 文件    
前进后退历史使用 URL 的 Hash 部分来控制
## 云计算是什么？前景怎么样？
互联网资源虚拟化，云是一种比喻的说法，用来表示互联网和底层基础设施的抽象，注册一个账号，用户无需关心底层，只要登陆到它们的云控制台，就可以购买和配置需要的服务
## String, StringBuilder 和 StringBuffer 的区别
* String 字符串变量不可变，每次对String类型进行改变，就等同于生成一个新的String对象，然后将指针指向新的 String 对象
* StringBuilder 字符串可变(非线程安全)
* StringBuffer  字符串可变(线程安全)，字符串缓冲区，但不能修改
