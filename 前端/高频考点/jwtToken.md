# session和token
http协议是无状态的，当一个用户通过用户名和密码登录之后，它的下一个请求不会携带任何状态，，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态  
目前主流的用户认证方法有基于token和基于session两种方式
## 基于session
1.用户输入其登录信息  
2.服务器验证信息是否正确并创建一个session,然后将其存储在数据库中  
3.服务器为用户生成一个sessionId，将具有sesssionId的Cookie将放置在用户浏览器中  
4.在后续请求中，会根据数据库验证sessionID，如果有效，则接受请求  
5.一旦用户注销应用程序，会话将在客户端和服务器端都被销毁
## 基于token(令牌)的用户认证
最常用的就是JSON Web Token(jwt)  
1.用户输入其登录信息  
2.服务器验证信息是否正确，并返回已经签名的token  
3.token储在客户端，例如存在local storage或cookie中  
4.之后的HTTP请求都将token添加到请求头里  
5.服务器解码JWT，并且如果令牌有效，则接受请求  
6.一旦用户注销，令牌将在客户端被销毁，不需要与服务器进行交互一个关键是，令牌是无状态的,**后端服务器不需要保存令牌或当前session的记录**  
一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名，这三个部分都是json格式
# 区别和优缺点
基于session和基于jwt的方式的主要区别就是用户的状态保存的位置，session是保存在服务端的，而jwt是保存在客户端的
## jwt的优点
* 可扩展性好 应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要
* 无状态jwt不在服务端存储任何状态，jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数
## jwt的缺点
* 安全性:由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全
* 性能：jwt太长了。由于是无状态使用JWT，所有的数据都被放到JWT里
* 一次性：想修改里面的内容，就必须签发一个新的jwt.一旦签发一个jwt，在到期之前就会始终有效，无法中途废弃.**续签** 如果你使用jwt做会话管理，传统的cookie续签方案一般都是框架自带的，session有效期30分钟，30分钟内如果有访问，有效期被刷新至30分钟。一样的道理，要改变jwt的有效时间，就要签发新的jwt
# jwt使用场景
适合jwt的场景:
* 有效期短
* 只希望被使用一次

比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。这种场景就适合使用jwt

