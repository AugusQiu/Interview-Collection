# 浏览器地址栏输入url回车发生了什么？
非常经典的面试题，知乎详细版：https://zhuanlan.zhihu.com/p/80551769  
总体来说，会发生如下事情:  
1.DNS解析  
2.TCP连接  
3.发送HTTP请求  
4.服务器处理请求并返回HTTP报文  
5.浏览器解析并渲染页面  
6.结束连接  

## 1.DNS解析
DNS解析的过程就是**寻找哪台机器有你所需资源的过程**。浏览器输入一个地址，比如：www.baidu.com ,其实这并不是百度网站真正意义上的地址。互联网中每一台计算机的**唯一标识是它的ip地址**，但是ip地址不方便记忆，所以用到了域名(注:一域名只能对应一个ip,但一个ip可以绑定多个域名)  
用户一般都喜欢直接输域名，所以首先要对域名做一个到ip地址的转换，这个过程就是DNS解析 
### 浏览器如何通过域名去查询 URL 对应的 IP 呢
* 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录
* 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找
* 路由缓存：路由器也有 DNS 缓存
* ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
* 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行**递归查询**（DNS 服务器先问根域名服务器 .com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）
**从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询**
## 2.TCP连接
建立TCP连接，也就是通常所说的三次握手，首先是客户端向服务器发送请求是否可以建立链接，服务器返回同意后，客户端回馈服务器的响应，即完成3次通话
## 3.发送HTTP请求
在完成TCP连接后，接下来就是客户端向服务端发送http请求，请求内容包括：
* 请求行：方法+地址+http版本
* 请求头
* 请求体  

请求行：  
````
GET www.baidu.com HTTP/1.1
````
请求方法分为GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE这些类型

请求头：  
请求头是指在客户端向服务器传递**请求的附加信息**和**客户端自身的信息**(客户端不一定特指浏览器) ,由**键/值**对组成
常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等

请求体  
当使用POST, PUT等方法时，通常需要客户端向服务器传递一些参数数据。这些数据就储存在请求体中，并不是所有请求都具有请求数据
````
name=tom&password=1234&realName=tomson
//承载着 name、password、realName 三个请求参数。
````

## 4.服务器处理请求并返回HTTP报文
服务器端收到http请求后会作出响应，响应内容包括：  
* 响应行：http版本+状态码+状态描述
````
HTTP/1.1 200 OK
````
* 响应头
* 响应体  

状态码  
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:  
* 1xx：指示信息–表示请求已接收，继续处理 
* 2xx：成功–表示请求已被成功接收、理解、接受
* 3xx：重定向–要完成请求必须进行更进一步的操作
* 4xx：客户端错误–请求有语法错误或请求无法实现
* 5xx：服务器端错误–服务器未能实现合法的请求  
平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500

响应头  
与请求头部类似，为响应报文添加了一些附加信息，常见的响应头有Server Content-Type Content-Length Content-Charset等

响应体  
包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据。通常后端返回的数据以及HTML, CSS, JS, 图片等文件就放在这一部分

## 5.浏览器解析渲染页面
https://juejin.im/post/6844904083212468238  
浏览器在收到HTML,CSS,JS文件后，它将这些信息渲染到客户端页面上  
一般分为以下五个步骤:  
1.根据 HTML 解析出 DOM 树
* 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个**深度优先遍历**。即**先构建当前节点的所有子节点，再构建下一个兄弟节点**
* 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕  

2.根据 CSS 解析生成 CSS 规则树
* 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪
* 浏览器在 CSS 规则树生成之前不会进行渲染

3.结合 DOM 树和 CSS 规则树，生成渲染树
* DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树
* 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度

4.根据渲染树计算每一个节点的信息（布局）
* 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的**位置**和**尺寸**
* 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染

5.根据计算好的信息绘制页面
* 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上
* 重绘：某个元素的背景**颜色**，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘
* 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染
## 渲染过程的注意点
* 分层(图层树)：为了方便3D变换，独立的合成层，拥有**层叠上下文属性**的标签会被提升为单独的一层：position:fixed、transform、opacity<1、video、canvas、iframe原生
* 栅格化：图块(tile)是渲染进程中的合成线程将图层划分为大小512x512或者256x256的区块，栅格化将图块生成位图
## <script>和<link>标签对DOM解析和渲染的影响
* script标签的**加载**、**执行**都会**阻止DOM的解析和渲染**，因为js可能操作DOM，防止渲染过程中出现不可预期的结果，所以让GUI渲染线程和js引擎线程互斥
* 阻塞渲染并不是页面不渲染，如果一定要等到js加载执行完再渲染，那用户等待时间太长，浏览器的设计肯定会尽早让用户看到页面，因此遇到script标签时，会触发一次Paint，浏览器会将script标签之前的元素渲染出来，但是有触发条件：1.是**带src属性**的script标签，inline script不会触发 2.**script标签要在body中**，head中不会触发
* link标签不会阻塞DOM的解析，但会阻塞DOM的渲染，以及阻塞其之后的script标签的执行
## script async和defer属性区别
1. 没有defer或async,浏览器会立即加载和执行指定脚本，而不等待后续载入的文档元素
2. 有async,加载script标签后续的文档元素和加载、执行script并行进行，**script加载时不阻塞，执行时会阻塞DOM解析**
3. 有defer,**跟async一样，异步加载script，不影响DOM的解析，而且，它的执行在所有DOM解析完成后，onload回调触发前执行**

## 6.连接结束关闭TCP链接
TCP四次挥手