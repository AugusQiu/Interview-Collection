https://cloud.tencent.com/developer/article/1514668
## node里的模块是什么
在node中，每个文件模块都是一个对象，它的定义如下
````
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  this.filename = null;
  this.loaded = false;
  this.children = [];
}

module.exports = Module;

var module = new Module(filename, parent);
````
**所有的模块都是 Module 的实例**,可以看到，当前模块（module.js）也是 Module 的一个实例
## require的模块加载机制
* 计算模块路径
* 如果模块在缓存里面，就取出缓存
* 加载模块
* 输出模块的exports属性即可
## 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到是没有这两个属性的，那么这两个属性是从哪里来的
每个module里面都会传入__filename, __dirname参数，这两个参数并不是module本身就有的，是外界传入的
## node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗
exports其实就是module.exports
## 介绍一下node事件循环(event loop)的过程
* 在进程启动时，Node会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick
* 每个Tick的过程就是查看任务队列中是否有事件待处理。如果有就取出事件及其相关的回调函数
* 然后进入下一个循环，如果不再有事件处理，就退出进程
## 每个tick的过程，如何判断是否有事件需要处理呢？
* 每个事件循环中有一个或多个观察者，判断是否有事件需要处理，也就是向这些观察者询问是否有要处理的事件
* 在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者
* 事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理
* 在windows下，这个循环基于IOCP(输入输出完成端口,是支持多个同时发生的异步I/O操作的应用程序编程接口)创建，在unix下则基于多线程创建
## 描述整个异步I/O的流程
### 异步调用阶段
````
发起调用->封装请求对象->设置参数和回调函数->将请求对象放入线程池等待执行
````
### 线程池
````
如果线程可用->执行请求对象中的I/O操作->将执行完成的结果放在请求对象中->通知IOCP调用完成->归还线程
````
### 事件循环
````
创建主循环 ->从I/O观察者取到可用的请求对象 -> 取出回调函数和结果调用执行 -> 线程池那儿获取完成的I/O交给I/O观察者
````
## 如何查看V8的内存使用情况
使用process.memoryUsage(),返回如下
````
{
  rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472,
  external: 49879
}
````
heapTotal 和 heapUsed 代表V8的内存使用情况; external代表V8管理的，绑定到Javascript的C++对象的内存使用情况; rss, 驻留集大小, 是给这个进程分配了多少物理内存(占总分配内存的一部分)，这些物理内存中包含堆，栈，和代码段
## V8的内存分代和回收算法请简单讲一讲
在V8中，主要将内存分为新生代和老生代两代。**新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象**
### 新生代
新生代中的对象主要通过**Scavenge算法**进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。**它将堆内存一份为二**，每一部分空间成为semispace。在这两个semispace空间中，**只有一个处于使用中，另一个处于闲置状态**。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间
* 当开始垃圾回收的时候，**会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放**。完成复制后，From空间和To空间发生角色对换
* 当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中
### 老生代
老生代主要采取的是标记清除的垃圾回收算，在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象


## 内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法
### 内存显露
内存泄漏(Memory Leak)指由于疏忽或错误，程序不用的内存未能及时释放  
如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢  
常见原因：闭包、全局变量、同一个事件重复监听(addEventListener)  
定位内存泄漏，可以**使用 heapdump 保存内存快照**

## 新建Buffer会占用V8分配的内存吗
不会，Buffer属于堆外内存，不是V8分配的