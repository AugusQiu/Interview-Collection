## 一，进程和线程的区别
进程：程序的一次运行，是系统资源分配和调度的一个独立单位  
线程：进程的一个执行单元，是CPU资源调度和分配的基本单位(单核CPU在执行多任务时，会在多任务间来回跳，这个最小的调度单位就是线程)
* 地址空间：进程拥有独立的地址空间；线程共享本进程的地址空间
* 拥有资源：进程是拥有系统资源的一个独立单位，而线程本身不拥有系统资源，只保留一点在运行中必不可少的资源(程序计数器、一组寄存器和栈)，和其它线程共享本进程的相关资源：内存、I/O、CPU等
* 独立性：一个进程崩溃后，在保护模式下不会对其它进程产生影响；但是一个线程崩溃，整个进程都会死掉。所以多进程比多线程健壮
* 系统开销：在进程切换时，涉及到整个当前进程 CPU环境的保护环境设置、新被调度运行的CPU环境的设置，而切换线程只需保存和设置少量寄存器的内容，不会涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销
* 执行过程：每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

## 二.进程间如何通讯
进程间通信(IPC,interProcess Communication)是指在不同进程之间传播或交换信息  
因为每个进程所拥有的资源都是独占的，想实现进程间通信就比较麻烦，需要让不同的进程看到一份公共资源，交换数据就得在内核中开辟一块缓冲区，**进程A 把数据从用户空间拷到内核缓冲区，进程B 再从缓冲区把数据读走**，这就是IPC
### IPC的方式有
* 管道(包括无名管道和命名管道)
* 消息队列
* 信号量
* 信号
* 消息队列
* 共享内存
* 套接字(socket)
* 远程过程调用:RPC等，RPC支持不同主机上的两个进程IPC  
### 1.管道(pipe)
既可在程序中使用，也可在shell中使用  
管道是一种**半双工**的通信方式，数据只能**单向**流动，管道的问题在于它们没有名字，只能在**父子进程**间使用  
管道由pipe函数创建，提供一个单向数据流。如果需要一个双向数据流，那就必须创建两个管道，一个方向一个，所以全双工管道其实就是两个半双工管道
### 2.命名管道(named pipe):即FIFO
命名管道也是**半双工**的通信方式，提供单向数据流，但是克服了管道没有名字的限制，而允许**无亲缘关系**的进程间通信

**扩展:**  
pipe和FIFO都是使用通常的read和write函数访问  
FIFO由mkfifo函数创建，**每个FIFO有一个路径名与之关联**，从而允许无亲缘关系的进程访问同一FIFO    
FIFO的优势表现在服务器可以是一个长期运行的进程(如守护进程)，而且与其客户没有亲缘关系  

### 3.信号量(semophore)
主要作为进程间或者同一进程内不同线程的**同步手段**  
进程间通信**处理同步互斥的机制**，信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种**锁机制**，防止某进程正在访问共享资源时，其他进程也在访问该资源

### 4.信号(sinal)
是一种**处理异步事件**的方式，用于通知接收进程某个事件已经发生。除了用于进程外，还可以发送信号给进程本身  
注意:信号不同于信号量，虽然都可用来实现同步和互斥，但是信号是使用信号处理器来进行，而信号量是使用PV(P通过 V释放)操作来实现的  

### 5.共享内存(shared memory)
是由一个进程创建，但多个进程都可以访问的同一块内存空间，是最快的可用IPC形式(因为共享内存区中的单个数据副本对于共享该内存的所有线程或进程都是可用的)  
一般IPC形式（管道、FIFO、消息队列）的问题在于，两个进程要交换信息，这些信息必须经由内核传递，而进程间共享内存时，交换数据就不再涉及内核 

### 6.远程过程调用:RPC
构筑一个应用程序时，如果所有进程都在同一台主机，那么可以使用前面的各种IPC方式；如果进程不在同一个主机上，那就需要某种形式的网络通信，RPC应运而生，它属于隐式网络编程的范畴  
RPC是用于**从一个系统(客户主机)上某个程序调用另一个系统上(服务器主机)某个函数**的一种方法，客户和服务器运行在不同主机上，调用进程和被调用进程在不同主机上执行，过程调用涉及网络IO；当然，**RPC也可以用于同一主机上的客户和服务器之间**，而被视为另一种形式的消息传递

## 三.进程有哪几种状态?
* 就绪状态:进程已获得除处理机以外的所需资源，等待分配处理机资源
* 运行状态:占用处理机资源运行，处于此状态的进程数小于等于CPU数
* 阻塞状态:进程等待某种条件，在条件满足之前无法执行

## 四.多线程的锁有哪些？
1.互斥锁  
用于保护临界区，确保同一时间只有一个线程访问数据，对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁  
2.自旋锁 
与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于循环检测保持者是否已经释放了锁(自旋)的状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。**自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态**  
3.信号量  
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段  
4.读写锁(rwlock)：
高级别锁，区分读和写，符合条件时允许多个线程访问对象。**处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁**， **处于写锁时则任何锁操作都会睡眠等待**；常见的操作系统会在写锁等待时屏蔽后续的读锁操作以防写锁被无限孤立而等待，在操作系统不支持情况下可以用引用计数加写优先等待来用互斥锁实现。 读写锁适用于大量读少量写的环境，但由于其特殊的逻辑使得其效率相对普通的互斥锁和自旋锁要慢一个数量级；值得注意的一点是按POSIX标准在线程申请读锁并未释放前本线程申请写锁是成功的，但运行后的逻辑结果是无法预测

## 五.什么是死锁？死锁产生的条件?
在两个或多个并发进程中，在执行过程中,因争夺资源而造成的一种**互相等待**的现象,若无外力作用,它们都将无法推进下去  
死锁产生的四个条件(有一个条件不成立，就不会产生死锁)：
* 互斥条件:一个资源一次只能被一个进程使用
* 请求和保持条件:一个进程因请求资源而阻塞时，对已经获得的资源保持不放
* 不剥夺条件:进程获得的资源，在未完全使用完之前，不能强行剥夺
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

## 六.什么是缓冲区溢出？有什么危害？其原因是什么?
缓冲区溢出是指当计算机向缓冲区填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法的数据上    
危害:程序崩溃;跳转执行一段恶意代码  
造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入  

## 七.分页和分段有什么区别？
**段是信息的逻辑单位**，它是根据**用户的需要**划分的，因此段对用户是可见的 ；**页是信息的物理单位**，是为了管理主存的方便而划分的，对用户是透明的。  
段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定  
段向用户提供二维地址空间；页向用户提供的是一维地址空间   
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制  

## 八.虚拟地址空间是什么?为什么要有虚拟地址空间？
虚拟地址空间:指应用程序自己认为自己所处的地址空间。不同于物理地址空间，后者是真实存在的，比如电脑有一根8G的内存条，物理地址空间就是0~8Gb。CPU的MMU(内存管理单元)负责把虚拟地址转换成物理地址  
好处:
* 程序员不再关心真实的物理内存空间是什么样的，理论上来说(64位CPU的虚拟内存为2^64)，程序员有几乎无限大的虚拟内存空间可用，最后只要建立虚拟地址和物理地址的对应关系即可
* 操作系统屏蔽了物理内存空间的细节，进程无法访问到操作系统禁止访问的物理地址，也不能访问到别的进程的地址空间，这大大增强了程序安全性
* 由虚拟地址空间引申出来的分页(Paging)技术，大大提高了内存的使用效率。要想运行一个程序，不再需要把整个程序都放入内存中执行，我们只要保证将要执行的页在内存中即可，如果不存在则导致页错误  

## 九.操作系统内核态，用户态
* 内核态:CPU可以访问内存所有数据，包括外设，如:硬盘、网卡。CPU也可以将自己从一个程序切换到另一个程序
* 用户态:只能受限的访问内存，不允许访问外设。占用CPU的能力被剥夺，CPU资源可以被其他程序获取  
### 为什么要有用户态和内核态？  
需要限制不同程序之间的访问能力，防止他们获取其他程序的内存数据，或者外设的数据
### 用户态与内核态的切换
所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情，比如从硬盘读取数据，或者从键盘获取输入等，而唯一能做这些事情的就只有操作系统  
这时就需要一个这样的机制:**用户态切换到内核态，但是不能控制在内核态中执行的指令**，这种机制叫**系统调用**，在CPU中的实现称之为陷阱指令(Trap Instruction)  
工作流程:  
1.用户态程序将一些数据值存放在寄存器中，或者使用参数创建一个堆栈(stack frame),以此表明需要操作系统提供的服务  
2.用户态程序执行陷阱指令  
3.CPU切换到内核态，并跳到位于内存指定位置的指令，这些指令是操作系统的一部分，它们具有内存保护，不可被用户态程序访问  
4.这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务  
5.系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果

## 十.栈和堆
* 栈:由系统自动分配的内存区域,由系统自动释放。例如：在函数中声明一个局部变量 int a;系统会自动在栈中为a开辟空间  
* 堆:需要程序员自己申请的内存区域，并指明大小，并且需要主动进行释放。 例如: 在c中malloc函数，如p1 = (char*)malloc(10);在C++中用new运算符如p2 = new char[10];
